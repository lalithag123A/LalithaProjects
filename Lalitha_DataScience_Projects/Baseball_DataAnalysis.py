# -*- coding: utf-8 -*-
"""DataScienceTEST_classnotes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-uRxRLY16gusM9zx0EujsiVDMUpcrMvQ

**Baseball Data Analysis**

1.1. Use SQL to compute a relation containing the total payroll and winning percentage
(i.e., number of wins/number of games * 100) for each team (i.e., for each teamID and yearID
combination). You should include other columns that will help when performing exploratory
data analysis later on (e.g., franchise IDs, number of wins, and number of games).
1.2. Include the SQL code you used to create this relation in your writeup. Describe
how you dealt with any missing data in these two relations. Specifically, indicate if there is
missing data in either table, and how the type of join you used determines how you dealt
with this missing data. You have to be careful about integer vs. float division in SQL.
"""

import sqlite3 # database connection for accessing the data
import pandas as pd # pandas used for data processing 

# connect the sqllite database
conn = sqlite3.connect("lahman2014.sqlite")

# get total payroll for each combination of teamId and yearId
# start with lower case and _ to connect multiple words and the second word.
salary_query = "SELECT teamID, yearID, sum(salary) as totalpayroll FROM Salaries GROUP BY teamId, yearId ORDER BY teamID"
team_salaries = pd.read_sql(salary_query, conn)

# to check if any colums has nulls 
# team_salaries.isnull().sum()

# get winning percentage for each combination of teamID and yearID
#winning_percentage_Query = """SELECT teamID, yearID, W as num_of_wins, G as num_of_games,
#           PRINTF('%2d%%', cast(W AS float)/G*100) as winning_percentage from Teams GROUP BY teamID, yearId ORDER BY teamID"""

# in order to not use as string for percentage for average plot, used different query
winning_percentage_Query = """SELECT teamID, yearID, W as num_of_wins, G as num_of_games,
           cast(W AS float)/G*100 as winning_percentage from Teams GROUP BY teamID, yearId ORDER BY teamID"""

winning_percentages = pd.read_sql(winning_percentage_Query, conn)           

# to check if any columns has nulls
# winning_percentages.isnull().sum()
pay_win_relation = winning_percentages.merge(team_salaries, how="inner", left_on=["teamID","yearID"], right_on=["teamID","yearID"] )
pay_win_relation
# move the totalpayroll left of winning percentage
# pay_win_relation = pd.merge(team_salaries, winning_percentages, left_on=["teamID","yearID"], right_on=["teamID","yearID"])
# pay_win_relation

# 1.2. There is no missing values in either relation and we have used intersection to join the two relations.

"""
2.1. Write code to produce plots that illustrate the distribution of payrolls across teams
conditioned on time from 1990 to 2014
"""

import seaborn as sns
new_pay_win_relation = pay_win_relation[(pay_win_relation["yearID"]>1989) & (pay_win_relation["yearID"]<2015)]
# new_pay_win_relation

# sns.set_context("paper")
sns.relplot(data = new_pay_win_relation["totalpayroll"], x = new_pay_win_relation["yearID"], y = new_pay_win_relation["totalpayroll"],kind="line", hue=new_pay_win_relation["teamID"], height=8, aspect=2)

sns.catplot(data = new_pay_win_relation.sort_values("totalpayroll"), x="yearID", y="totalpayroll",kind="boxen",height=8, aspect=2)

"""2.2. What statements can you make about the distribution of payrolls conditioned on
time based on these plots? You can make statements using central tendency, spread, etc..

Answer: 1. The average payroll of teams increases over time.
2. The payroll difference between teams enlarges over time.

2.3. Write code to produce plots that specifically show at least one of the statements
you made in subtask 2
"""

# average pay roll over time
# shadow is some payrolls in top and bottom
sns.relplot(data = pd.DataFrame(new_pay_win_relation["totalpayroll"]).mean(), x = new_pay_win_relation["yearID"], y = new_pay_win_relation["totalpayroll"],kind="line",height=8, aspect=2, color="r")

"""Correlation between payroll and winning percentage
2.4. Write code to discretize year into five time periods (you can use pandas.cut to
accomplish this) and then make a scatterplot showing mean winning percentage (y-axis)
vs. mean payroll (x-axis) for each of the five time periods. You could add a regression line
using NumPy’s polyfit in each scatter plot to ease interpretation
"""

import matplotlib.pyplot as plt

#discretize year into 5 time periods
time_periods = ["1990-1994","1995-1999","2000-2005","2005-2009","2009-2014"]
new_pay_win_relation["time_period"] = pd.cut(new_pay_win_relation["yearID"],5, labels = time_periods)
new_pay_win_relation

for time_period in time_periods:
  period_pay_win_relation = new_pay_win_relation[new_pay_win_relation.time_period == time_period]

  period_total_payroll = period_pay_win_relation.pivot(index="yearID", columns = "teamID", values = "totalpayroll" )
  x_axis = period_total_payroll.mean()

  period_win_percentage = period_pay_win_relation.pivot(index="yearID", columns = "teamID", values = "winning_percentage" )
  y_axis = period_win_percentage.mean()
  
  sns.regplot(x_axis, y_axis, color="r")
  plt.title(time_period)
  plt.xlabel("mean payroll")
  plt.ylabel("mean win percentage")

  for i, team in enumerate(x_axis.index):
    plt.text(x_axis[i]+0.2, y_axis[i]+0.2, team)
  plt.figure()

"""2.5. What can you say about team payrolls across these periods? Are there any teams
that standout as being particularly good at paying for wins across these time periods? What
2
can you say about the Oakland A’s spending efficiency across these time periods. Note that
labelling points in the scatterplot can help interpretation.

Task 3: Data Transformations.
Standardizing across years
It looks like comparing payrolls across years is problematic. Let us do a transformation
that will help with these comparisons.
3.1. Create a new variable in your dataset that standardizes payroll conditioned on
year. This column for team i in year j should equal:
standardized payrollij =
payrollij−avg payrollj
sj
,
where avg payrollj
is the average payroll for year j, and sj is the standard deviation of
payroll for year j.
"""

import numpy as np
# one way is to open sqllite connection, below is standard way to convert sqllite connection to dataframe
!pip install -U pandasql
from pandasql import sqldf 

# get the average payroll per year
mean_payroll = "SELECT yearID, AVG(totalpayroll) AS avg_payroll FROM new_pay_win_relation GROUP BY yearID"
mean_payroll = sqldf(mean_payroll, globals())
mean_payroll

# standardized payroll for team i in year j
new_column = []

for row in new_pay_win_relation.iterrows():
  # conducting operations on column we include 1
  # same year with multiple total payroll, so we include 1 for total pay roll, one for yearID to do by rows
  payroll = row[1]["totalpayroll"]
  yearID = row[1]["yearID"]
  # compare the yearIDs and get the avg_payroll per year
  avg_payroll = mean_payroll.loc("yearID" == yearID)[0][1]

  s = np.std(new_pay_win_relation[new_pay_win_relation["yearID"] == yearID]["totalpayroll"])

  # standard deviation may be zero, we need to handle it
  if(s != 0):
    standardized_payroll = (payroll - avg_payroll)/s
  else:
    standardized_payroll = 0  

  # append the standardized payroll calculated to column and then add that to data frame 
  new_column.append(standardized_payroll)

new_pay_win_relation["Standardized_Payroll"] = new_column

new_pay_win_relation

"""3.2. Repeat the same plots as those in subtask 2.4, but use this new standardized
payroll variable.
"""

new_pay_win_relation

import matplotlib.pyplot as plt

new_pay_win_relation["Standardized_Payroll"]

#discretize year into 5 time periods
time_periods = ["1990-1994","1995-1999","2000-2005","2005-2009","2009-2014"]
new_pay_win_relation["time_period"] = pd.cut(new_pay_win_relation["yearID"],5, labels = time_periods)
new_pay_win_relation

for time_period in time_periods:
  period_pay_win_relation = new_pay_win_relation[new_pay_win_relation.time_period == time_period]

  period_total_payroll = period_pay_win_relation.pivot(index="yearID", columns = "teamID", values = "totalpayroll" )
  x_axis = period_total_payroll.mean()

  period_st_percentage = period_pay_win_relation.pivot(index="yearID", columns = "teamID", values = "Standardized_Payroll" )
  y_axis = period_st_percentage.mean()
  
  sns.regplot(x_axis, y_axis, color="r")
  plt.title(time_period)
  plt.xlabel("mean payroll")
  plt.ylabel("mean standardized percentage")

  for i, team in enumerate(x_axis.index):
    plt.text(x_axis[i]+0.2, y_axis[i]+0.2, team)
  plt.figure()

"""3.3. Discuss how the plots from subtasks 2.4 and 3.2 reflect the transformation you
did on the payroll variable.

"""

